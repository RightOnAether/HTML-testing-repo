<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Emoji Isaac ‚Äî Mini</title>
<style>
  :root{
    --bg:#0f1724;
    --accent:#7dd3fc;
    --muted:#9aa7b2;
    --card:#0b1228;
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial;}
  body{
    background:linear-gradient(180deg,#071228 0%, #061b2b 60%);
    display:flex;align-items:center;justify-content:center;
    color:#e6f3fb;
  }
  .wrap{width:960px;max-width:96vw;background:rgba(255,255,255,0.02);
    border-radius:18px;padding:18px;box-shadow:0 10px 30px rgba(2,6,23,0.7);
  }
  h1{font-size:20px;margin:0}
  .card{background:var(--card);padding:10px;border-radius:12px;}
  #gameCanvas{display:block;background:#081e2b;width:100%;height:640px;
    border-radius:12px;border:6px solid rgba(255,255,255,0.02);box-sizing:border-box;}
  .overlay{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;}
  .panel{width:520px;max-width:92vw;padding:18px;border-radius:14px;
    background:rgba(0,0,0,0.6);text-align:center;}
  button.big{margin-top:12px;padding:10px 18px;border-radius:10px;border:none;
    background:var(--accent);color:#06202b;font-weight:700;cursor:pointer;font-size:15px;}
</style>
</head>
<body>
<div class="wrap">
  <h1>Emoji Isaac ‚Äî Mini</h1>
  <canvas id="gameCanvas" width="880" height="640"></canvas>

  <div id="overlay" class="overlay">
    <div id="titleScreen" class="panel">
      <h2>Emoji Isaac</h2>
      <p>Move: WASD &nbsp; Shoot: Arrow Keys</p>
      <button id="startBtn" class="big">Start</button>
    </div>
    <div id="gameOverScreen" class="panel" style="display:none;">
      <h2>Game Over</h2>
      <p id="goMsg"></p>
      <button id="restartBtn" class="big">Restart</button>
    </div>
  </div>
</div>

<script>
const canvas=document.getElementById('gameCanvas');
const ctx=canvas.getContext('2d');
const W=canvas.width,H=canvas.height;

let state="title";
let player,enemies=[],bullets=[],keys={},shootDirs={},wave=1,score=0;

const rand=(a,b)=>a+Math.random()*(b-a);
const choice=a=>a[Math.floor(Math.random()*a.length)];
const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const dist=(a,b)=>Math.hypot(a.x-b.x,a.y-b.y);

function newPlayer(){
  return{x:W/2,y:H/2,r:20,vx:0,vy:0,speed:2,dmg:1,range:200,hp:3,
    fireRate:180,lastShot:0,emoji:"üôÇ",bulletsModifiers:{pierce:0,bounce:0,size:8,speed:6}};
}

const ENEMY_POOL=["üòà","üëø","ü¶π","üò°","üë∫","üßü","üíÄ","‚ò†Ô∏è","üòæ","üòµ"];

function spawnEnemy(x,y,level=1){
  enemies.push({x,y,vx:0,vy:0,r:16+level*2,speed:0.6+0.2*level,hp:1+level,emoji:choice(ENEMY_POOL)});
}

function spawnWave(n){
  enemies=[];
  for(let i=0;i<5+n;i++)spawnEnemy(rand(40,W-40),rand(40,H-40),n);
}

function startRun(){
  player=newPlayer();bullets=[];wave=1;score=0;
  spawnWave(wave);
  document.getElementById('titleScreen').style.display="none";
  document.getElementById('gameOverScreen').style.display="none";
  state="playing";
}

function handleDeath(){
  state="gameover";
  document.getElementById('overlay').style.display="flex";
  document.getElementById('gameOverScreen').style.display="block";
  document.getElementById('goMsg').textContent=`You reached wave ${wave}`;
}

window.addEventListener('keydown',e=>{
  keys[e.key.toLowerCase()]=true;
  if(e.key.startsWith("Arrow")){shootDirs[e.key]=true;e.preventDefault();}
});
window.addEventListener('keyup',e=>{
  keys[e.key.toLowerCase()]=false;
  if(e.key.startsWith("Arrow"))shootDirs[e.key]=false;
});

document.getElementById('startBtn').onclick=startRun;
document.getElementById('restartBtn').onclick=startRun;

function createBullet(x,y,dx,dy){
  const b={x,y,vx:dx*player.bulletsModifiers.speed,vy:dy*player.bulletsModifiers.speed,
           r:player.bulletsModifiers.size,life:player.range};
  bullets.push(b);
}

function tryShoot(now){
  const dirs=[];
  if(shootDirs["ArrowLeft"])dirs.push({x:-1,y:0});
  if(shootDirs["ArrowRight"])dirs.push({x:1,y:0});
  if(shootDirs["ArrowUp"])dirs.push({x:0,y:-1});
  if(shootDirs["ArrowDown"])dirs.push({x:0,y:1});
  if(!dirs.length)return;
  if(now-player.lastShot<player.fireRate)return;
  player.lastShot=now;
  dirs.forEach(d=>createBullet(player.x,player.y,d.x,d.y));
}

function update(dt,now){
  if(state!=="playing")return;
  let mx=0,my=0;
  if(keys['w'])my-=1;if(keys['s'])my+=1;if(keys['a'])mx-=1;if(keys['d'])mx+=1;
  const mag=Math.hypot(mx,my)||1;
  player.vx+=(mx/mag*player.speed-player.vx)*0.2;
  player.vy+=(my/mag*player.speed-player.vy)*0.2;
  player.x+=player.vx;player.y+=player.vy;
  player.x=clamp(player.x,player.r,W-player.r);
  player.y=clamp(player.y,player.r,H-player.r);
  tryShoot(now);

  bullets.forEach(b=>{
    b.x+=b.vx;b.y+=b.vy;b.life-=Math.hypot(b.vx,b.vy);
  });
  bullets=bullets.filter(b=>b.life>0);

  for(let e of enemies){
    const dx=player.x-e.x,dy=player.y-e.y,d=Math.hypot(dx,dy)||1;
    e.vx+=(dx/d*e.speed-e.vx)*0.04;
    e.vy+=(dy/d*e.speed-e.vy)*0.04;
    e.x+=e.vx;e.y+=e.vy;
    if(dist(e,player)<e.r+player.r){player.hp-=1;e.hp=0;if(player.hp<=0)handleDeath();}
  }

  // remove dead enemies from poison or collisions
  enemies=enemies.filter(e=>e.hp>0);

  // bullet collisions
  for(let bi=bullets.length-1;bi>=0;bi--){
    const b=bullets[bi];
    for(let ei=enemies.length-1;ei>=0;ei--){
      const e=enemies[ei];
      if(dist(b,e)<b.r+e.r){
        e.hp-=player.dmg;
        bullets.splice(bi,1);
        if(e.hp<=0){enemies.splice(ei,1);score+=10;}
        break;
      }
    }
  }

  if(!enemies.length){wave++;spawnWave(wave);player.hp=Math.min(player.hp+1,5);}
}

function drawEmoji(x,y,r,emoji){
  ctx.font=`${r*1.6}px serif`;
  ctx.textAlign="center";ctx.textBaseline="middle";
  ctx.fillText(emoji,x,y);
}

function render(){
  ctx.fillStyle="#081e2b";ctx.fillRect(0,0,W,H);
  enemies.forEach(e=>drawEmoji(e.x,e.y,e.r,e.emoji));
  bullets.forEach(b=>{ctx.beginPath();ctx.arc(b.x,b.y,b.r,0,Math.PI*2);ctx.fillStyle="#7dd3fc";ctx.fill();});
  drawEmoji(player.x,player.y,player.r,player.emoji);
  ctx.fillStyle="#fff";ctx.font="14px sans-serif";
  ctx.fillText(`HP:${player.hp} Wave:${wave} Score:${score}`,20,20);
}

let last=0;
function loop(ts){
  if(!last)last=ts;
  const dt=ts-last;last=ts;
  update(dt,ts);render();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
